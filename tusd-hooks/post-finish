#!/bin/sh
# Tusd post-finish hook script

# Exit immediately if a command exits with a non-zero status.
set -e

# --- Configuration ---
# Base directory where tusd stores files INSIDE THE CONTAINER
TUSD_DATA_DIR="/srv/tusd-data"

# --- Log Environment Variables (for debugging) ---
echo "--- Tusd Hook Environment Variables ---" >&2
env | grep TUS_ | sort >&2
echo "---------------------------------------" >&2

# --- Get Metadata ---
# Tusd provides metadata via environment variables prefixed with TUS_META_
# Keys are uppercased, and hyphens are replaced with underscores.
UPLOAD_ID="$TUS_ID"
TOKEN="$TUS_META_TOKEN"
ORIGINAL_FILENAME="$TUS_META_FILENAME" # Still attempt to get filename from metadata

# --- Validate Base Info ---
if [ -z "$UPLOAD_ID" ]; then
  echo "Error: TUS_ID environment variable is missing." >&2
  exit 1 # Exit with error
fi
if [ -z "$TOKEN" ]; then
  echo "Error: TUS_META_TOKEN environment variable is missing." >&2
  # If token is missing, we cannot proceed
  exit 1 # Exit with error
fi
# If filename is missing from metadata, try to get it from the .info file as a fallback
if [ -z "$ORIGINAL_FILENAME" ]; then
  echo "Warning: TUS_META_FILENAME is missing. Attempting to read from .info file." >&2
  INFO_FILE_PATH="$TUSD_DATA_DIR/$UPLOAD_ID.info"
  if [ -f "$INFO_FILE_PATH" ]; then
      # Attempt to parse filename from JSON in .info file (fragile)
      ORIGINAL_FILENAME=$(grep '"filename":' "$INFO_FILE_PATH" | sed -n 's/.*"filename":"\([^"]*\)".*/\1/p')
      if [ -n "$ORIGINAL_FILENAME" ]; then
          # Basic Base64 decoding (assuming it was base64 encoded)
          ORIGINAL_FILENAME=$(echo "$ORIGINAL_FILENAME" | base64 -d)
          echo "Successfully extracted filename from .info file: $ORIGINAL_FILENAME" >&2
      else
          echo "Error: Could not parse filename from .info file." >&2
          exit 1 # Cannot proceed without a filename
      fi
  else
      echo "Error: .info file not found at $INFO_FILE_PATH. Cannot determine filename." >&2
      exit 1 # Cannot proceed without a filename
  fi
fi


echo "Processing upload ID: $UPLOAD_ID" >&2
echo "Using Token: $TOKEN" >&2
echo "Original Filename: $ORIGINAL_FILENAME" >&2

# --- Fetch Client/Project Info from Backend ---
BACKEND_API_URL="http://backend:5001/api/upload/upload-links/$TOKEN"
echo "Fetching project info from backend: $BACKEND_API_URL" >&2

# Use curl to get the data. Add error handling.
# The -f flag makes curl fail silently on server errors (HTTP 4xx, 5xx)
API_RESPONSE=$(curl -fsS "$BACKEND_API_URL")
CURL_EXIT_CODE=$?

if [ $CURL_EXIT_CODE -ne 0 ]; then
    echo "Error: Failed to fetch data from backend API (curl exit code: $CURL_EXIT_CODE). URL: $BACKEND_API_URL" >&2
    exit 1 # Exit with error
fi

if [ -z "$API_RESPONSE" ]; then
    echo "Error: Received empty response from backend API. URL: $BACKEND_API_URL" >&2
    exit 1 # Exit with error
fi

echo "Received API Response: $API_RESPONSE" >&2

# --- Parse Client Code and Project Name from JSON (Using jq) ---
# Use jq to safely parse the JSON response.
# -e flag makes jq exit with non-zero status if the key path doesn't exist or value is null/false
# -r flag outputs raw strings without quotes
CLIENT_CODE=$(echo "$API_RESPONSE" | jq -er '.data.project.client.code')
JQ_CLIENT_EXIT_CODE=$?
PROJECT_NAME=$(echo "$API_RESPONSE" | jq -er '.data.project.name')
JQ_PROJECT_EXIT_CODE=$?

# Validate extracted values based on jq exit codes
if [ $JQ_CLIENT_EXIT_CODE -ne 0 ]; then
  echo "Error: Failed to parse Client Code from API response using jq (jq exit code: $JQ_CLIENT_EXIT_CODE)." >&2
  echo "API Response was: $API_RESPONSE" >&2
  exit 1 # Exit with error
fi
if [ $JQ_PROJECT_EXIT_CODE -ne 0 ]; then
  echo "Error: Failed to parse Project Name from API response using jq (jq exit code: $JQ_PROJECT_EXIT_CODE)." >&2
  echo "API Response was: $API_RESPONSE" >&2
  exit 1 # Exit with error
fi

# Double-check if values are empty even if jq succeeded (e.g., empty strings in JSON)
if [ -z "$CLIENT_CODE" ]; then
  echo "Error: Failed to parse Client Code from API response." >&2
  echo "Error: Parsed Client Code is empty." >&2
  echo "API Response was: $API_RESPONSE" >&2
  exit 1 # Exit with error
fi
if [ -z "$PROJECT_NAME" ]; then
  echo "Error: Parsed Project Name is empty." >&2
  echo "API Response was: $API_RESPONSE" >&2
  exit 1 # Exit with error
fi

echo "Parsed Client Code: $CLIENT_CODE" >&2
echo "Parsed Project Name: $PROJECT_NAME" >&2

# --- Sanitize Paths (Basic) ---
# Replace potentially problematic characters with underscores
# A more robust solution might be needed depending on expected inputs
SANITIZED_CLIENT_CODE=$(echo "$CLIENT_CODE" | sed 's/[^a-zA-Z0-9_-]/_/g')
SANITIZED_PROJECT_NAME=$(echo "$PROJECT_NAME" | sed 's/[^a-zA-Z0-9_-]/_/g')
# Prevent path traversal and replace slashes in filename
SANITIZED_FILENAME=$(echo "$ORIGINAL_FILENAME" | sed 's#/#_#g' | sed 's#\\#_#g' | sed 's/\.\.//g')

echo "Sanitized Client Code: $SANITIZED_CLIENT_CODE" >&2
echo "Sanitized Project Name: $SANITIZED_PROJECT_NAME" >&2
echo "Sanitized Filename: $SANITIZED_FILENAME" >&2

# --- Define Paths ---
SOURCE_FILE_PATH="$TUSD_DATA_DIR/$UPLOAD_ID"
SOURCE_INFO_PATH="$TUSD_DATA_DIR/$UPLOAD_ID.info"
DESTINATION_DIR="$TUSD_DATA_DIR/$SANITIZED_CLIENT_CODE/$SANITIZED_PROJECT_NAME"
DESTINATION_FILE_PATH="$DESTINATION_DIR/$SANITIZED_FILENAME"
DESTINATION_INFO_PATH="$DESTINATION_DIR/$SANITIZED_FILENAME.info"

echo "Source File: $SOURCE_FILE_PATH" >&2
echo "Source Info: $SOURCE_INFO_PATH" >&2
echo "Destination Dir: $DESTINATION_DIR" >&2
echo "Destination File: $DESTINATION_FILE_PATH" >&2
echo "Destination Info: $DESTINATION_INFO_PATH" >&2

# --- Create Destination Directory ---
echo "Creating destination directory: $DESTINATION_DIR" >&2
if ! mkdir -p "$DESTINATION_DIR"; then
  echo "Error: Failed to create destination directory '$DESTINATION_DIR'." >&2
  exit 1 # Exit with error
fi
echo "Destination directory created or already exists." >&2

# --- Move Files ---
# Check if source file exists
if [ ! -f "$SOURCE_FILE_PATH" ]; then
    echo "Error: Source file '$SOURCE_FILE_PATH' not found." >&2
    exit 1 # Exit with error
fi

echo "Moving data file..." >&2
if ! mv "$SOURCE_FILE_PATH" "$DESTINATION_FILE_PATH"; then
  echo "Error: Failed to move data file '$SOURCE_FILE_PATH' to '$DESTINATION_FILE_PATH'." >&2
  exit 1 # Exit with error
fi
echo "Data file moved successfully." >&2

# Check if source info file exists before moving (it should, but check anyway)
if [ -f "$SOURCE_INFO_PATH" ]; then
    echo "Moving info file..." >&2
    if ! mv "$SOURCE_INFO_PATH" "$DESTINATION_INFO_PATH"; then
      # Log warning but don't fail the hook if only info file move fails
      echo "Warning: Failed to move info file '$SOURCE_INFO_PATH' to '$DESTINATION_INFO_PATH'." >&2
    else
      echo "Info file moved successfully." >&2
    fi
else
    echo "Warning: Source info file '$SOURCE_INFO_PATH' not found. Skipping move." >&2
fi

echo "Hook script finished successfully for upload ID: $UPLOAD_ID" >&2

# Exit with 0 to indicate success to tusd
exit 0
